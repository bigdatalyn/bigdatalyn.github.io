---
layout: post
title: "MySQL 8.0 Study 006 Tips"
category: MySQL
tags: MySQL Tips
---

* content
{:toc}

MySQL 8.0 Study 006 Tips

学习系列

- MySQL Using temporary




### MySQL Using temporary


Using temporary表示由于排序没有走索引、使用union、子查询连接查询,group_concat（）或count（distinct）表达式的求值等等创建了一个内部临时表。

注意这里的临时表可能是内存上的临时表，也有可能是硬盘上的临时表，理所当然基于内存的临时表的时间消耗肯定要比基于硬盘的临时表的实际消耗小。

但不是说多大临时数据都可以直接存在内存的临时表，而是当超过最大内存临时表的最大容量就是转为存入磁盘临时表

当mysql需要创建临时表时，选择内存临时表还是硬盘临时表取决于参数`tmp_table_size`和`max_heap_table_size`，当所需临时表的容量大于两者的最小值时，mysql就会使用硬盘临时表存放数据。

用户可以在mysql的配置文件里修改该两个参数的值，两者的默认值均为16M。

```
mysql [localhost:8032] {msandbox} (test) > show global variables like 'max_heap_table_size';
+---------------------+----------+
| Variable_name       | Value    |
+---------------------+----------+
| max_heap_table_size | 16777216 |
+---------------------+----------+
1 row in set (0.01 sec)

mysql [localhost:8032] {msandbox} (test) > show global variables like 'tmp_table_size';
+----------------+----------+
| Variable_name  | Value    |
+----------------+----------+
| tmp_table_size | 16777216 |
+----------------+----------+
1 row in set (0.00 sec)

mysql [localhost:8032] {msandbox} (test) > explain select job,count(*) from emp group by job;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |   100.00 | Using temporary |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+
1 row in set, 1 warning (0.00 sec)

mysql [localhost:8032] {msandbox} (test) > 
```

mysql 的 sql_mode 开启了 ONLY_FULL_GROUP_BY 模式

```
该模式的含义就是: 对于group by聚合操作，如果在select中的列，没有在group by中出现，那么这个sql是不合法的，因为列不在group by从句中。
```


group by 优化:

```
1.分组字段加索引
2.order by null 不排序(如果是已经走了索引，或者说8.0的版本，那都不需要加 order by null，因为上面也说了8.0默认就是不排序的了)
3.尽量使用内存临时表(内存临时表的大小是有限制的，mysql 中 tmp_table_size 代表的就是内存临时表的大小，默认是 16M->适当调整)
4.SQL_BIG_RESULT
```

`SQL_BIG_RESULT`使用示例:

```
mysql [localhost:8032] {msandbox} (test) > explain select sql_big_result job,count(*) from emp group by job;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)

mysql [localhost:8032] {msandbox} (test) > 
```

order by 优化

```
1.排序字段加索引
2.只select需要的字段
  - 查询的字段较多可能导致数据会超出sort_buffer的容量，超出之后就需要用到磁盘临时文件，排序的性能会很差
  - 当select的字段大小总和>max_length_for_sort_data，排序算法会将 全字段排序 改为 rowid排序 增加一次回表查询
3.尝试提高 sort_buffer_size
4.尝试提高 max_length_for_sort_data
  - 如果设的太高，数据总容量超出sort_buffer_size的概率就增大，超出之后就需要用到磁盘临时文件，排序的性能会很差
```


```
mysql [localhost:8032] {msandbox} (test) > explain select * from sbtest1 where k<200000 order by c limit 10;
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+---------------------------------------+
| id | select_type | table   | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+---------------------------------------+
|  1 | SIMPLE      | sbtest1 | NULL       | range | k_1           | k_1  | 4       | NULL |   29 |   100.00 | Using index condition; Using filesort |
+----+-------------+---------+------------+-------+---------------+------+---------+------+------+----------+---------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql [localhost:8032] {msandbox} (test) > 
```

说明:

```
Extra 这个字段的Using index condition 表示该查询走了索引,但需要回表查询

Extra 这个字段的 Using filesort 表示使用了内部排序

一般出现Using filesort 也是我们需要考虑优化的点。

Using filesort: 表示没有走索引排序,而是走了内部排序，这时MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。

实际上，sort_buffer的大小是由一个参数控制的：sort_buffer_size。

如果要排序的数据小于sort_buffer_size，排序在sort_buffer 内存中完成，如果要排序的数据大于sort_buffer_size，则借助磁盘文件来进行排序

我们可以通过下面的方法来确定一个排序语句是否使用了临时文件。

/* 打开optimizer_trace，只对本线程有效 */
SET optimizer_trace='enabled=on'; 

/* 执行语句 */
select * from sbtest1 where k<200000 order by c limit 10;

/* 查看 OPTIMIZER_TRACE 输出 */
SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`;


number_of_tmp_files 表示使用来排序的磁盘临时文件数。

如果number_of_tmp_files>0，则表示使用了磁盘文件来进行排序。
```

rowid排序

```
就是只把查询SQL需要用于排序的字段和主键id，放到sort_buffer中。

什么情况走全字段排序,什么情况下走rowid排序？

它们的切换通过一个参数控制的这个参数就是max_length_for_sort_data 它表示MySQL用于排序行数据的长度的一个参数，如果单行的长度超过这个值，MySQL 就认为单行太大，就换rowid 排序。

全字段排序：如果sort_buffer内存足够，那效率是最高的，但如果sort_buffer内存不够的话，就需要用到磁盘临时文件，排序的性能会很差。
rowid排序：虽然sort_buffer可以放更多数据了，相对于全字段排序而言,rowid排序会多一次回表查询。

MySQL的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。
```



### Referece

参考:

[MySQL-不能忽略的 COLLATION](https://juejin.cn/post/6959466033082007559)



Have a good work&life! 2023/01 via LinHong


