---
layout: post
title: "MySQL 8.0 Study 012 Tips"
category: MySQL
tags: MySQL Tips
---

* content
{:toc}

MySQL 8.0 Study 012 Tips

学习系列
- MySQL CTE
- MySQL Window Function 窗口函数
- MySQL dbdeployer Percona Server 
- MySQL IO线程及相关参数调优







### MySQL CTE

CTE(公用表表达式)是一个命名的临时结果集，仅在单个SQL语句的执行范围内存在。与派生表类似，CTE不作为对象存储，仅在查询执行期间持续。与派生表不同，CTE可以是自引用。此外，与派生表相比，CTE提供了更好的可读性和性能。CTE的结构包括:名称，可选列列表和定义CTE的查询。定义CTE后，可以像SELECT，INSERT，UPDATE，DELETE或视图一样使用。

CTE有两种用法，非递归的CTE和递归的CTE。非递归的CTE可以用来增加代码的可读性，增加逻辑的结构化表达。递归的CTE，应用的场景也比较多，比如查询某结构下的子结构，每个子结构下面的子结构等等，就需要使用递归的方式。递归的CTE当然递归不会无限下去，不同的数据库有不同的递归限制，MySQL8.0中默认限制的最大递归次数是1000。超过最大低估次数会报错：`Recursive query aborted after 1001 iterations. Try increasing @@cte_max_recursion_depth to a larger value`，由参数`cte_max_recursion_depth`决定。

```
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| cte_max_recursion_depth | 1000  |
+-------------------------+-------+
```

语法:

```
with_clause:
    WITH [RECURSIVE]
        cte_name [(col_name [, col_name] ...)] AS (subquery)
        [, cte_name [(col_name [, col_name] ...)] AS (subquery)] ...
#cte_name命名单个公用表表达式，并且可以在包含该WITH子句的语句中用作表引用。
subquery部分称为“CTE的子查询”，是产生CTE结果集的部分。
如果公用表表达式的子查询引用其自己的名称，则该表表达式是递归的，RECURSIVE关键字必须被包含。
```

递归示例:
```
mysql [localhost:8032] {msandbox} (test) > WITH RECURSIVE cte (n) AS (SELECT 1   UNION ALL   SELECT n + 1 FROM cte WHERE n < 10 ) SELECT * FROM cte;
+------+
| n    |
+------+
|    1 |
|    2 |
|    3 |
|    4 |
|    5 |
|    6 |
|    7 |
|    8 |
|    9 |
|   10 |
+------+
10 rows in set (0.00 sec)

mysql [localhost:8032] {msandbox} (test) > 
mysql [localhost:8032] {msandbox} (test) > WITH RECURSIVE cte (n) AS (SELECT 1   UNION ALL   SELECT n + 1 FROM cte WHERE n < 1001 ) SELECT * FROM cte;
ERROR 3636 (HY000): Recursive query aborted after 1001 iterations. Try increasing @@cte_max_recursion_depth to a larger value.
mysql [localhost:8032] {msandbox} (test) > 
```

`cte_max_recursion_depth` 系统变量强制对CTE的递归水平的数量限制。服务器终止任何递归级别高于此变量值的CTE的执行。
`max_execution_time` 系统变量强制用于执行超时 SELECT在当前会话中执行的语句。该`MAX_EXECUTION_TIME` 优化器提示强制为每个查询执行超时SELECT在它出现的语句。

```
#### 在执行CTE语句之前执行如下语句：

SET max_execution_time = 1000; -- impose one second timeout

#### 或者，在CTE语句本身中包含优化程序提示：

WITH RECURSIVE cte (n) AS
(
  SELECT 1
  UNION ALL
  SELECT n + 1 FROM cte
)
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM cte;
```

窗口函数和CTE(公用表表达式)的增加，简化了SQL代码的编写和逻辑的实现，新特性的增加，可以用更优雅和可读性的方式来写SQL。
不过这都是在MySQL8.0中实现的新功能，在MySQL8.0之前，只能按照较为复杂的方式实现。

### MySQL Window Function 窗口函数

[MySQL8.0窗口汗水 Window Function](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html)
```
序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()
分布函数：PERCENT_RANK()、CUME_DIST()
前后函数：LAG()、LEAD()
头尾函数：FIRST_VALUE()、LAST_VALUE()
其他函数：NTH_VALUE()、NTILE()
```


### MySQL dbdeployer Percona Server 

下载:(2023/02)
```
https://www.percona.com/downloads

wget https://downloads.percona.com/downloads/Percona-Server-8.0/Percona-Server-8.0.31-23/binary/tarball/Percona-Server-8.0.31-23-Linux.x86_64.glibc2.28-minimal.tar.gz
```

Ref:

[Using dbdeployer to manage MySQL, Percona Server and MariaDB sandboxes](https://www.percona.com/blog/using-dbdeployer-to-manage-mysql-percona-server-and-mariadb-sandboxes/)

```
dbdeployer unpack --prefix=ps Percona-Server-8.0.31-23-Linux.x86_64.glibc2.28-minimal.tar.gz
or
dbdeployer --sandbox-binary=/opt/mysql/ unpack mysql-8.0.31-linux-glibc2.12-x86_64.tar.xz 

dbdeployer --sandbox-binary=/opt/mysql/ deploy single 8.0.31
```

### MySQL IO线程及相关参数调优

参考:

[MySQL IO线程及相关参数调优](https://www.cnblogs.com/geaozhang/p/7214257.html)


### Referece

参考:

[MySQL8.0之CTE(公用表表达式)](https://developer.aliyun.com/article/719994)


Have a good work&life! 2023/02 via LinHong


