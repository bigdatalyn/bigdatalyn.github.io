
### MySQL Dept/Emp 测试数据


```
/*部门表,存在则进行删除 */
drop table if EXISTS dep;
create table dep(
    id int unsigned primary key auto_increment,
    depno mediumint unsigned not null default 0,
    depname varchar(20) not null default "",
    memo varchar(200) not null default ""
);

/*员工表,存在则进行删除*/
drop table if EXISTS emp;
create table emp(
    id int unsigned primary key auto_increment,
    empno mediumint unsigned not null default 0,
    empname varchar(20) not null default "",
    job varchar(9) not null default "",
    mgr mediumint unsigned not null default 0,
    hiredate datetime not null,
    sal decimal(7,2) not null,
    comn decimal(7,2) not null,
    depno mediumint unsigned not null default 0
);


/* 产生随机字符串的函数*/
DELIMITER $
drop FUNCTION if EXISTS rand_string;
CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)
DETERMINISTIC
BEGIN
    DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmlopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i INT DEFAULT 0;
    WHILE i < n DO
    SET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
    SET i = i+1;
    END WHILE;
    RETURN return_str;
END $
DELIMITER ;


/*产生随机部门编号的函数*/
DELIMITER $
drop FUNCTION if EXISTS rand_num;
CREATE FUNCTION rand_num() RETURNS INT(5)
DETERMINISTIC
BEGIN
    DECLARE i INT DEFAULT 0;
    SET i = FLOOR(100+RAND()*10);
    RETURN i;
END $
DELIMITER ;


-- 编写存储过程，模拟50W的员工数据

/*建立存储过程：往emp表中插入数据*/
DELIMITER $
drop PROCEDURE if EXISTS insert_emp;
CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))
DETERMINISTIC
BEGIN
    DECLARE i INT DEFAULT 0;
    /*set autocommit =0 把autocommit设置成0，把默认提交关闭*/
    SET autocommit = 0;
    REPEAT
    SET i = i + 1;
    INSERT INTO emp(empno,empname,job,mgr,hiredate,sal,comn,depno) VALUES ((START+i),rand_string(6),'SALEMAN',0001,now(),2000,400,rand_num());
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END $
DELIMITER ;
/*插入50W条数据*/
call insert_emp(0,500000);

-- 编写存储过程，模拟50的部门数据

/*建立存储过程：往dep表中插入数据*/
DELIMITER $
drop PROCEDURE if EXISTS insert_dept;
CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))
DETERMINISTIC
BEGIN
    DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
    SET i = i+1;
    INSERT  INTO dep( depno,depname,memo) VALUES((START+i),rand_string(10),rand_string(8));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END $
DELIMITER ;
/*插入120条数据*/
call insert_dept(1,20);


/*建立关键字段的索引:排序、条件*/
CREATE INDEX idx_emp_id ON emp(id);
CREATE INDEX idx_emp_depno ON emp(depno);
CREATE INDEX idx_dep_depno ON dep(depno); 

```


```
mysql> select count(*) from emp;
+----------+
| count(*) |
+----------+
|   500000 |
+----------+
1 row in set (0.05 sec)

mysql> select count(*) from dep;
+----------+
| count(*) |
+----------+
|       20 |
+----------+
1 row in set (0.00 sec)

mysql> 
```

### 查看mysql语句运行时间

```
https://www.cnblogs.com/happySmily/p/5943311.html

确定支持show profile 后，查看profile是否开启，数据库默认是不开启的。变量profiling是用户变量，每次都得重新启用。

   查看方法： show variables like "%pro%";

   设置开启方法： 
   set profiling = 1;

   show profiles
   show profile
   show profile for query 1 即可查看第1个sql语句的执行的各个操作的耗时详情。

```



### 测试


/*偏移量为100，取25*/
SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25;
/*偏移量为400000，取25*/
SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno order by a.id desc limit 400000,25;

explain SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25;


mysql> show profiles;
+----------+------------+-------------------------------------------------------------------------------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                                                                                                     |
+----------+------------+-------------------------------------------------------------------------------------------------------------------------------------------+
|        1 | 0.00005525 | shwo profile                                                                                                                              |
|        2 | 0.00031875 | select count(*) from dep                                                                                                                  |
|        3 | 0.00037700 | SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25    |
|        4 | 0.49666500 | SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno order by a.id desc limit 400000,25 |
+----------+------------+-------------------------------------------------------------------------------------------------------------------------------------------+
4 rows in set, 1 warning (0.00 sec)

mysql> 


#### 使用索引覆盖+子查询优化

因为我们有主键id，并且在上面建了索引，所以可以先在索引树中找到开始位置的 id值，再根据找到的id值查询行数据。
```
/*子查询获取偏移100条的位置的id，在这个位置上往后取25*/
SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno
where a.id >= (select id from emp order by id limit 100,1)
order by a.id limit 25;

/*子查询获取偏移400000条的位置的id，在这个位置上往后取25*/
SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno
where a.id >= (select id from emp order by id limit 400000,1)
order by a.id limit 25;
```

#### 起始位置重定义

记住上次查找结果的主键位置，避免使用偏移量 offset
```
/*记住了上次的分页的最后一条数据的id是100，这边就直接跳过100，从101开始扫描表*/
SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno
where a.id > 100 order by a.id limit 25;

/*记住了上次的分页的最后一条数据的id是400000，这边就直接跳过400000，从4800001开始扫描表*/
SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname
from emp a left join dep b on a.depno = b.depno
where a.id > 400000
order by a.id limit 25;
```
这个效率是最好的，无论怎么分页，耗时基本都是一致的，因为他执行完条件之后，都只扫描了25条数据。
但是有个问题，只适合一页一页的分页，这样才能记住前一个分页的最后Id。如果用户跳着分页就有问题了，比如刚刚刷完第25页，马上跳到35页，数据就会不对。
这种的适合场景是类似百度搜索或者腾讯新闻那种滚轮往下拉，不断拉取不断加载的情况。这种延迟加载会保证数据不会跳跃着获取。

#### 降级策略

看了网上一个阿里的dba同学分享的方案：配置limit的偏移量和获取数一个最大值，超过这个最大值，就返回空数据。
因为他觉得超过这个值你已经不是在分页了，而是在刷数据了，如果确认要找数据，应该输入合适条件来缩小范围，而不是一页一页分页。
这个跟我同事的想法大致一样：request的时候 如果offset大于某个数值就先返回一个4xx的错误。 

### 测试

```
mysql> show index from dep;
+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| dep   |          0 | PRIMARY       |            1 | id          | A         |           1 |     NULL | NULL   |      | BTREE      |         |               |
| dep   |          1 | idx_dep_depno |            1 | depno       | A         |          20 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
2 rows in set (0.00 sec)

mysql> show index from emp;
+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| emp   |          0 | PRIMARY       |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_id    |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_depno |            1 | depno       | A         |           9 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
3 rows in set (0.00 sec)

mysql> 
```

#### 01.看type为all和possible_keys为空 表示没有索引

```
mysql> explain select * from emp where id=10;
+----+-------------+-------+------------+-------+--------------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys      | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+--------------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | emp   | NULL       | const | PRIMARY,idx_emp_id | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+--------------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from emp where empno=10;
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 498348 |    10.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> 


alter table <table> add index idx_name (<col_name>);

```

#### 02.隐式的类型转换，索引失效

empname 字段为字串类型，是B+树的普通索引，如果查询条件传了一个数字过去，会导致索引失效。

看Type 一个为ref 一个为ALL

```
mysql> alter table emp add index idx_emp_empname(empname);
Query OK, 0 rows affected (1.29 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql>
mysql> explain select * from emp where empname='123';
+----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | emp   | NULL       | ref  | idx_emp_empname | idx_emp_empname | 62      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from emp where empname='123';
+----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | emp   | NULL       | ref  | idx_emp_empname | idx_emp_empname | 62      | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from emp where empname=123;
+----+-------------+-------+------------+------+-----------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys   | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+-----------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | idx_emp_empname | NULL | NULL    | NULL | 498348 |    10.00 | Using where |
+----+-------------+-------+------------+------+-----------------+------+---------+------+--------+----------+-------------+
1 row in set, 3 warnings (0.00 sec)

mysql> 
```

#### 03.查询条件包含or，可能导致索引失效

```
mysql> desc dep;
+---------+-----------------------+------+-----+---------+----------------+
| Field   | Type                  | Null | Key | Default | Extra          |
+---------+-----------------------+------+-----+---------+----------------+
| id      | int(10) unsigned      | NO   | PRI | NULL    | auto_increment |
| depno   | mediumint(8) unsigned | NO   | MUL | 0       |                |
| depname | varchar(20)           | NO   |     |         |                |
| memo    | varchar(200)          | NO   |     |         |                |
+---------+-----------------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)

mysql> explain select * from dep where depno=2 or depname='abc';
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | dep   | NULL       | ALL  | idx_dep_depno | NULL | NULL    | NULL |   20 |    14.50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> 
```
注意：如果or条件的列都加了索引，索引可能会走也可能不走，大家可以自己试一试哈。但是平时大家使用的时候，还是要注意一下这个or，学会用explain分析。遇到不走索引的时候，考虑拆开两条SQL。

#### 04.like通配符可能导致索引失效

并不是用了like通配符，索引一定会失效，而是like查询是以%开头，才会导致索引失效。

like查询以%开头，索引失效
把%放后面，发现索引还是正常走的

```
mysql> show index from emp;
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| emp   |          0 | PRIMARY         |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_id      |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_depno   |            1 | depno       | A         |           9 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_empname |            1 | empname     | A         |      345381 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
4 rows in set (0.00 sec)

mysql> explain select * from emp where empname like 'mysql%';
+----+-------------+-------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | emp   | NULL       | range | idx_emp_empname | idx_emp_empname | 62      | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from emp where empname like '%mysql';
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 498348 |    11.11 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> 
```

#### 05.查询条件不满足联合索引的左匹配原则

MySQl建立联合索引时，会遵循左前缀匹配的原则，即左优先。如果你建立一个（a,b,c）的联合索引，相当于建立了(a)、(a,b)、(a,b,c)三个索引。

```
mysql> show index from emp;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| emp   |          0 | PRIMARY  |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
1 row in set (0.00 sec)

mysql> alter table emp add index idx_emp_id_depno_empname(id,depno,empname);
Query OK, 0 rows affected (1.23 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show index from emp;
+-------+------------+--------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name                 | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+--------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| emp   |          0 | PRIMARY                  |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_id_depno_empname |            1 | id          | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_id_depno_empname |            2 | depno       | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
| emp   |          1 | idx_emp_id_depno_empname |            3 | empname     | A         |      498348 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+--------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
4 rows in set (0.00 sec)

mysql> 
```

#### 06.在索引列上使用mysql的内置函数

可以把内置函数的逻辑转移到右边

#### 07.对索引进行列运算

对索引进行列运算（如，+、-、*、/）,索引不生效

```
mysql> explain select * from emp where id=1;
+----+-------------+-------+------------+-------+----------------------------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys                    | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+----------------------------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | emp   | NULL       | const | PRIMARY,idx_emp_id_depno_empname | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+----------------------------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from emp where id+1=1;
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 498348 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> 
```

#### 08.索引字段上使用

索引字段上使用（！= 或者 < >），索引可能失效

其实这个也是跟mySQL优化器有关，如果优化器觉得即使走了索引，还是需要扫描很多很多行的哈，它觉得不划算，不如直接不走索引。平时我们用！= 或者< >，not in的时候，留点心眼哈

#### 09.索引字段上使用is null， is not null


索引字段上使用is null， is not null，索引可能失效

```
mysql> explain select * from emp where id is null;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from emp where id is not null;
+----+-------------+-------+------------+------+----------------------------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys                    | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+----------------------------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | PRIMARY,idx_emp_id_depno_empname | NULL | NULL    | NULL | 498348 |    90.00 | Using where |
+----+-------------+-------+------------+------+----------------------------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> 
```

如果type=range,要注意一下哈，因为这个可能因为数据量问题，导致索引。

#### 10.左右连接，关联的字段编码格式不一样

在做表关联时，注意一下关联字段的编码问题哈。

user表的name字段编码是utf8mb4，而user_job表的name字段编码为utf8。

```
mysql> CREATE TABLE `user` (
    ->   `id` int(11) NOT NULL AUTO_INCREMENT,
    ->   `name` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL,
    ->   `age` int(11) NOT NULL,
    ->   PRIMARY KEY (`id`),
    ->   KEY `idx_name` (`name`) USING BTREE
    -> ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
Query OK, 0 rows affected (0.02 sec)

mysql> 
mysql> CREATE TABLE `user_job` (
    ->   `id` int(11) NOT NULL,
    ->   `userId` int(11) NOT NULL,
    ->   `job` varchar(255) DEFAULT NULL,
    ->   `name` varchar(255) DEFAULT NULL,
    ->   PRIMARY KEY (`id`),
    ->   KEY `idx_name` (`name`) USING BTREE
    -> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
Query OK, 0 rows affected (0.01 sec)

mysql> 
mysql> explain select u.name,j.name,j.job from user u left join user_job j on u.name=j.name;
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | u     | NULL       | index | NULL          | idx_name | 1023    | NULL |    1 |   100.00 | Using index                                        |
|  1 | SIMPLE      | j     | NULL       | ALL   | NULL          | NULL     | NULL    | NULL |    1 |   100.00 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

如果把它们的name字段改为编码一致，相同的SQL，还是会走索引。

```
CREATE TABLE `user1` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

explain select u.name,j.name,j.job from user1 u left join user_job j on u.name=j.name;

mysql> explain select u.name,j.name,j.job from user1 u left join user_job j on u.name=j.name;
+----+-------------+-------+------------+-------+---------------+----------+---------+-------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref         | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------------+------+----------+-------------+
|  1 | SIMPLE      | u     | NULL       | index | NULL          | idx_name | 768     | NULL        |    1 |   100.00 | Using index |
|  1 | SIMPLE      | j     | NULL       | ref   | idx_name      | idx_name | 768     | test.u.name |    1 |   100.00 | NULL        |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)

mysql> 
```

#### 11.优化器选错了索引

MySQL 中一张表是可以支持多个索引的。写SQL语句的时候，没有主动指定使用哪个索引的话，用哪个索引是由MySQL来确定的。

日常开发中，不断地删除历史数据和新增数据的场景，有可能会导致MySQL选错索引。

那么有哪些解决方案呢？
```
使用force index 强行选择某个索引
修改你的SQl，引导它使用我们期望的索引
优化你的业务逻辑
优化你的索引，新建一个更合适的索引，或者删除误用的索引。
```

#### 12.limit深分页问题

如何优化深分页问题

可以通过减少回表次数来优化。

一般有标签记录法和延迟关联法。

标签记录法
```
就是标记一下上次查询到哪一条了，下次再来查的时候，从该条开始往下扫描。就好像看书一样，上次看到哪里了，你就折叠一下或者夹个书签，下次来看的时候，直接就翻到啦。
假设上一次记录到100000，则SQL可以修改为：
select  id,name,balance FROM account where id > 100000 limit 10;
```
延迟关联法
```
延迟关联法，就是把条件转移到主键索引树，然后减少回表。如下：
select  acct1.id,acct1.name,acct1.balance FROM account acct1 INNER JOIN (SELECT a.id FROM account a WHERE a.create_time > '2020-09-19' limit 100000, 10) AS acct2 on acct1.id= acct2.id;
优化思路就是，先通过idx_create_time二级索引树查询到满足条件的主键ID，再与原表通过主键ID内连接，这样后面直接走了主键索引了，同时也减少了回表。
```

#### 13.单表数据量太大

单表数据量太大为什么会变慢？

一个表的数据量达到好几千万或者上亿时，加索引的效果没那么明显啦。性能之所以会变差，是因为维护索引的B+树结构层级变得更高了，查询一条数据时，需要经历的磁盘IO变多，因此查询性能变慢。

一个B+树大概可以存放多少数据量呢？

InnoDB存储引擎小储存单元是页，一页大小就是16k。

B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据；

假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数*单个叶子节点记录行数。

如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.
非叶子节点内存放多少指针呢？我们假设主键ID为bigint类型，长度为8字节(面试官问你int类型，一个int就是32位，4字节)，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170
因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，也就是说，可以存放两千万左右的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。

如果B+树想存储更多的数据，那树结构层级就会更高，查询一条数据时，需要经历的磁盘IO变多，因此查询性能变慢。

#### 14.delete in子查询不走索引


```
CREATE TABLE `old_account` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键Id',
  `name` varchar(255) DEFAULT NULL COMMENT '账户名',
  `balance` int(11) DEFAULT NULL COMMENT '余额',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1570068 DEFAULT CHARSET=utf8 ROW_FORMAT=REDUNDANT COMMENT='老的账户表';

CREATE TABLE `account` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键Id',
  `name` varchar(255) DEFAULT NULL COMMENT '账户名',
  `balance` int(11) DEFAULT NULL COMMENT '余额',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1570068 DEFAULT CHARSET=utf8 ROW_FORMAT=REDUNDANT COMMENT='账户表';

explain select * from account where name in (select name from old_account);

explain delete from account where name in (select name from old_account);
```

```
mysql> explain select * from account where name in (select name from old_account);
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------------+------+----------+----------------------------------+
| id | select_type | table       | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                            |
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------------+------+----------+----------------------------------+
|  1 | SIMPLE      | account     | NULL       | ALL  | idx_name      | NULL     | NULL    | NULL              |    1 |   100.00 | Using where                      |
|  1 | SIMPLE      | old_account | NULL       | ref  | idx_name      | idx_name | 768     | test.account.name |    1 |   100.00 | Using index; FirstMatch(account) |
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------------+------+----------+----------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> 
mysql> explain delete from account where name in (select name from old_account);
+----+--------------------+-------------+------------+----------------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type        | table       | partitions | type           | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+--------------------+-------------+------------+----------------+---------------+----------+---------+------+------+----------+-------------+
|  1 | DELETE             | account     | NULL       | ALL            | NULL          | NULL     | NULL    | NULL |    1 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | old_account | NULL       | index_subquery | idx_name      | idx_name | 768     | func |    1 |   100.00 | Using index |
+----+--------------------+-------------+------------+----------------+---------------+----------+---------+------+------+----------+-------------+
2 rows in set (0.00 sec)

mysql> 
```
从explain结果可以发现：先全表扫描 account，然后逐行执行子查询判断条件是否满足；显然，这个执行计划和我们预期不符合，因为并没有走索引。

原因是：
可以发现，实际执行的时候，MySQL对select in子查询做了优化，把子查询改成join的方式，所以可以走索引。但是很遗憾，对于delete in子查询，MySQL却没有对它做这个优化。
```
mysql> explain select * from account where name in (select name from old_account);
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------------+------+----------+----------------------------------+
| id | select_type | table       | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                            |
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------------+------+----------+----------------------------------+
|  1 | SIMPLE      | account     | NULL       | ALL  | idx_name      | NULL     | NULL    | NULL              |    1 |   100.00 | Using where                      |
|  1 | SIMPLE      | old_account | NULL       | ref  | idx_name      | idx_name | 768     | test.account.name |    1 |   100.00 | Using index; FirstMatch(account) |
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------------+------+----------+----------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show warnings;
+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                                                                                                                                                                                                                                                                            |
+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Note  | 1003 | /* select#1 */ select `test`.`account`.`id` AS `id`,`test`.`account`.`name` AS `name`,`test`.`account`.`balance` AS `balance`,`test`.`account`.`create_time` AS `create_time`,`test`.`account`.`update_time` AS `update_time` from `test`.`account` semi join (`test`.`old_account`) where (`test`.`old_account`.`name` = `test`.`account`.`name`) |
+-------+------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> 
```

通过上面的分析，显然可以把delete in子查询改为join的方式。我们改为join的方式后，再explain看下：

```
explain delete a from account a inner join old_account b on a.name=b.name;
```
可以发现，改用join的方式是可以走索引的，完美解决了这个问题。

实际上，对于update或者delete子查询的语句，MySQL官网也是推荐join的方式优化
```
mysql> explain delete a from account a inner join old_account b on a.name=b.name;
+----+-------------+-------+------------+------+---------------+----------+---------+-------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref         | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------+------+----------+-------------+
|  1 | DELETE      | a     | NULL       | ALL  | idx_name      | NULL     | NULL    | NULL        |    1 |   100.00 | Using where |
|  1 | SIMPLE      | b     | NULL       | ref  | idx_name      | idx_name | 768     | test.a.name |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------+------+----------+-------------+
2 rows in set (0.00 sec)

mysql> 
```

其实呢，给表加别名，也可以解决这个问题哦，如下:

```
mysql> explain delete a from account as a where a.name in (select name from old_account);
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------+------+----------+----------------------------+
| id | select_type | table       | partitions | type | possible_keys | key      | key_len | ref         | rows | filtered | Extra                      |
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------+------+----------+----------------------------+
|  1 | DELETE      | a           | NULL       | ALL  | idx_name      | NULL     | NULL    | NULL        |    1 |   100.00 | Using where                |
|  1 | SIMPLE      | old_account | NULL       | ref  | idx_name      | idx_name | 768     | test.a.name |    1 |   100.00 | Using index; FirstMatch(a) |
+----+-------------+-------------+------------+------+---------------+----------+---------+-------------+------+----------+----------------------------+
2 rows in set (0.00 sec)

mysql> 
```


### JOIN 表

MySQL中，join的执行算法，分别是：Index Nested-Loop Join和Block Nested-Loop Join。

Index Nested-Loop Join：这个join算法，跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引。
Block Nested-Loop Join：这种join算法，被驱动表上没有可用的索引,它会先把驱动表的数据读入线程内存join_buffer中，再扫描被驱动表，把被驱动表的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。
join过多的问题：

一方面，过多的表连接，会大大增加SQL复杂度。另外一方面，如果可以使用被驱动表的索引那还好，并且使用小表来做驱动表，查询效率更佳。如果被驱动表没有可用的索引，join是在join_buffer内存做的，如果匹配的数据量比较小或者join_buffer设置的比较大，速度也不会太慢。但是，如果join的数据量比较大时，mysql会采用在硬盘上创建临时表的方式进行多张表的关联匹配，这种显然效率就极低，本来磁盘的 IO 就不快，还要关联。

一般情况下，如果业务需要的话，关联2~3个表是可以接受的，但是关联的字段需要加索引哈。如果需要关联更多的表，建议从代码层面进行拆分，在业务层先查询一张表的数据，然后以关联字段作为条件查询关联表形成map，然后在业务层进行数据的拼装。

1）在关联查询的时候，尽量在被驱动表的关联字段上加索引，让MySQL做join操作时尽量选择INLJ算法。
2）小表做驱动表！
当使用left join时，左表是驱动表，右表是被驱动表，当使用right join时，右表是驱动表，左表是被驱动表，当使用join时，mysql会选择数据量比较小的表作为驱动表，
大表作为被驱动表，如果说我们在 join的时候明确知道哪张表是小表的时候,可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间。
对于小表定义的明确：
在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。

3）在适当的情况下增大 join buffer 的大小，当然这个好是在会话级别的增大，而不是全局级别。
4）不要用 * 作为查询列表，只返回需要的列！

这样做的好处可以让在相同大小的join buffer可以存更多的数据,也可以在存在索引的情况下尽可能避免回表查询数据。

join_buffer_size: 4M
```
mysql> show global variables like 'innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.01 sec)

mysql> show global variables like 'join_buffer_size';
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| join_buffer_size | 262144 |
+------------------+--------+
1 row in set (0.00 sec)

mysql> select 16384*262144/1024/1024/1024;
+-----------------------------+
| 16384*262144/1024/1024/1024 |
+-----------------------------+
|              4.000000000000 |
+-----------------------------+
1 row in set (0.01 sec)

mysql> 
```
为什么我们设置成4m呢？我们假设我们的mysql所在的vm是128gb，一根这样的join（如果被用到）是4M，1万个也不过用掉40G,而根据官方说法，total加在一起产生的join_buffer_size不要超过你所在系统的50%.
```
[mysqld]
join_buffer_size = 16M
```
临时设置:
```
set session join_buffer_size = 1024 * 1024 * 1024; 
select * from ...;  
set session join_buffer_size=default; 
或者
mysql>select /*+  set_var(join_buffer_size=1G) */ * from ...;
```

join buffer 缓存外表(驱动表)的在sql查询中设计的字段

### Explain

介绍下每一项的含义

id
SELECT识别符。这是SELECT的查询序列号

select_type
SELECT类型,可以为以下任何一种:

SIMPLE: 简单SELECT(不使用UNION或子查询)
PRIMARY: 最外面的SELECT
UNION: UNION中的第二个或后面的SELECT语句
DEPENDENT UNION: UNION中的第二个或后面的SELECT语句,取决于外面的查询
UNION RESULT: UNION 的结果
SUBQUERY: 子查询中的第一个SELECT
DEPENDENT SUBQUERY: 子查询中的第一个SELECT,取决于外面的查询
DERIVED: 导出表的SELECT(FROM子句的子查询)
table
输出的行所引用的表

type
联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:

system: 表仅有一行(=系统表)。这是const联接类型的一个特例。
const: 表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!
eq_ref: 对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。
ref: 对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。
ref_or_null: 该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。
index_merge: 该联接类型表示使用了索引合并优化方法。
unique_subquery: 该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。
index_subquery: 该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)
range: 只检索给定范围的行,使用一个索引来选择行。
index: 该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。
ALL: 对于每个来自于先前的表的行组合,进行完整的表扫描。
possible_keys
指出MySQL能使用哪个索引在该表中找到行

key
显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。

key_len
显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。

ref
显示使用哪个列或常数与key一起从表中选择行。

rows
显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。

filtered
显示了通过条件过滤出的行数的百分比估计值。

Extra
该列包含MySQL解决查询的详细信息

Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。
Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。
range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。
Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。
Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。
Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。
Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。
Using sort_union(…), Using union(…), Using intersect(…):这些函数说明如何为index_merge联接类型合并索引扫描。
Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。



